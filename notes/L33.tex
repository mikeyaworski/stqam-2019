\documentclass[11pt]{article}
\usepackage{url}
\usepackage{listings}
\usepackage{tikz}
\usepackage{fontspec}
\usepackage{enumitem}
\setmainfont{Latin Modern Roman}
\setmonofont{Cousine}[Scale=MatchLowercase]
\usetikzlibrary{arrows,automata,shapes}
\tikzstyle{block} = [rectangle, draw, fill=blue!20, 
    text width=5em, text centered, rounded corners, minimum height=2em]
\tikzstyle{bt} = [rectangle, draw, fill=blue!20, 
    text width=1em, text centered, rounded corners, minimum height=2em]

\newtheorem{defn}{Definition}
\newtheorem{crit}{Criterion}
\newcommand{\true}{\mbox{\sf true}}
\newcommand{\false}{\mbox{\sf false}}

\newcommand{\handout}[5]{
  \noindent
  \begin{center}
  \framebox{
    \vbox{
      \hbox to 5.78in { {\bf Software Testing, Quality Assurance and Maintenance } \hfill #2 }
      \vspace{4mm}
      \hbox to 5.78in { {\Large \hfill #5  \hfill} }
      \vspace{2mm}
      \hbox to 5.78in { {\em #3 \hfill #4} }
    }
  }
  \end{center}
  \vspace*{4mm}
}

\newcommand{\lecture}[4]{\handout{#1}{#2}{#3}{#4}{Lecture #1}}
\topmargin 0pt
\advance \topmargin by -\headheight
\advance \topmargin by -\headsep
\textheight 8.9in
\oddsidemargin 0pt
\evensidemargin \oddsidemargin
\marginparwidth 0.5in
\textwidth 6.5in

\parindent 0in
\parskip 1.5ex
%\renewcommand{\baselinestretch}{1.25}

\usepackage[listings]{tcolorbox}
\newtcbinputlisting{\codelisting}[3][]{
    extrude left by=1em,
    extrude right by=2em,
    listing file={#3},
    fonttitle=\bfseries,
    listing options={basicstyle=\ttfamily\footnotesize,numbers=left,language=Java,#1},
    listing only,
    hbox,
}
\lstset{ %
language=Java,
basicstyle=\ttfamily,commentstyle=\scriptsize\itshape,showstringspaces=false,breaklines=true,numbers=left}

\definecolor{gray}{rgb}{0.4,0.4,0.4}
\definecolor{darkblue}{rgb}{0.0,0.0,0.6}
\definecolor{cyan}{rgb}{0.0,0.6,0.6}

\lstdefinelanguage{XML}
{
  morestring=[b]",
  morestring=[s]{>}{<},
  morecomment=[s]{<?}{?>},
  stringstyle=\color{black},
  identifierstyle=\color{darkblue},
  keywordstyle=\color{cyan},
  morekeywords={xmlns,version,type}% list your attributes here
}


\begin{document}

\lecture{33 --- April 3, 2019}{Winter 2019}{Patrick Lam}{version 1}

\section*{One more dynamic tool: Randoop}
    Key Idea:
    ``Writing tests is a difficult and time-consuming activity, 
  and yet it is a crucial part of good software engineering. 
  Randoop automatically generates unit tests for Java classes.''

  Randoop generates random sequence of method calls, 
  looking for object contract violations.
  
  To use it, simply point it at a program \& let it run.

  Randoop discards bad method sequences 
(e.g. illegal argument exceptions). It remembers method sequences that create complex objects,
    and sequences that result in object contract violations.\

  \begin{center}
    \url{code.google.com/p/randoop/}
  \end{center}

  Here is an example generated by Randoop:
  {\scriptsize
\begin{lstlisting}[language=Java]
public static void test1() {
    LinkedList list = new LinkedList();
    Object o1 = new Object();
    list.addFirst(o1);

    TreeSet t1 = new TreeSet(list);
    Set s1 = Collections.synchronizedSet(t1);

    // violated in the Java standard library!
    Assert.assertTrue(s1.equals(s1));
  }
\end{lstlisting}
}

\section*{Course Summary}
Many of the topics in this course are fairly straightforward. I hope that seeing them
all in one place can help you make connections between the different topics.

\subsection*{Introduction}
We started by talking about \emph{faults}, \emph{errors}, and \emph{failures}.
We also discussed \emph{static} versus \emph{dynamic} approaches, something which recurred
throughout the course. 

\subsection*{Defining Test Suites}
Before defining test suites, I thought it was important for everyone to understand
\emph{exploratory testing}. We then moved on to \emph{statement} and \emph{branch}
coverage, which require you to understand \emph{control-flow graphs}. Alternatively,
you might have a \emph{Finite State Machine} and want to build test suites to cover
round-trips in your FSM.

Grammar-based approaches are also important, particularly \emph{fuzzing} for security-based
properties. (Don't forget to try out the american fuzzy lop tool). We can also generate
inputs from a grammar.

\emph{Mutation testing} is probably the most difficult concept in the course. Recall that
it's indirect: you're trying to make your test suite better by making sure that it can actually
detect defects in the code.

We also looked at research which empirically evaluated best-case coverage of well-tested code
(JUnit, can reach 93\%; 80\% is usual benchmark); which evaluated the usefulness of mutation
testing (it actually works); and which evaluated the usefulness of coverage (not very, as a
goal in itself).

\subsection*{Engineering Test Suites}
We then moved on to discuss how to engineer test suites as artifacts. There's a lot more
that I would have liked to talk about, like ensuring testability and test smells. But here's
what we did discuss.

First, we talked about why you need good tests---it enables you to fearlessly modify your code
without worrying about breaking it (``eat your vegetables!'') We then talked about some
\emph{test design principles}. Moving on to more concrete points, we saw how Selenium let you
write tests for webapps. \emph{Regression testing} is also a key use for test suites; they should
be fast and automated.

Tests themselves should be \emph{self-checking}. They might verify either \emph{state} or
\emph{behaviour} (using \emph{mock objects}). They should be hooked up to a \emph{continuous
integration} system and should not be \emph{flaky}.

\subsection*{Tools}
A fundamental distinction is between \emph{dynamic} and \emph{static} approaches. Dynamic approaches
have perfect information about a limited set of runs; static approaches have approximations which
are valid for all runs.

We talked about bug-finding tools somewhat out of sequence to enable
you to work on your project.  The fundamental idea behind Coverity is
to find contradictions and suspicious usage patterns. Your project
does the same, but at a simpler level.

On to real tools, the first technique I talked about was still not a tool:
\emph{code review}. Along the same lines, \emph{reporting bugs} is also important
to talk about, but not strictly speaking a tool either.

We finally continued with real tools: \emph{PMD} and \emph{FindBugs},
which statically detect suspicious code patterns in Java source code
and bytecode respectively. We also saw how to use PMD to run queries
on your own codebases (using XPath expressions). {\tt jshint} is another
tool in the same spirit, but it detects sketchiness in JavaScript
(like undefined variables, which you can't even use in sane languages).
\emph{Facebook Infer} uses more powerful static analysis to find memory
leaks and null pointer dereferences, among others. All of these tools
work on significant codebases.

Finally, on the dynamic tool side, we talked about \emph{valgrind}
and \emph{Address Sanitizer}, which detect memory errors at runtime
by instrumenting the code.


\end{document}
